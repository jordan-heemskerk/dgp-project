#include <csc486a/closeness_constraint.hpp>
#include <csc486a/rigid_constraint.hpp>
#include <csc486a/circle_constraint.hpp>
#include <csc486a/scaling_constraint.hpp>
#include <csc486a/sphere_constraint.hpp>
#include <csc486a/solver.hpp>
#include <csc486a/window_base.hpp>
#include <optional.hpp>
#include <OpenGP/GL/GlfwWindow.h>
#include <OpenGP/SurfaceMesh/SurfaceMesh.h>
#include <cstdlib>
#include <cstring>
#include <deque>
#include <iostream>
#include <deque>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <tuple>
#include <unordered_map>
#include <utility>


namespace {

    class sphere_demo : public csc486a::window_base {
        private:

        std::deque<csc486a::closeness_constraint> ccs_;
        std::deque<csc486a::rigid_constraint> rcs_;
        //std::optional<csc486a::line_constraint> lc_;
        std::deque<csc486a::circle_constraint> circlecs_;

        protected:

        public:

        explicit sphere_demo (OpenGP::SurfaceMesh mesh) : csc486a::window_base(std::move(mesh)) {
            //closeness constraints
            std::vector<OpenGP::SurfaceMesh::Vertex> va;
            for (auto && v : mesh_.vertices()) {
               ccs_.emplace_back(mesh_,v,1.0f);
               va.push_back(v);
            }

            //circle constraint on 40 vertices
            std::vector<OpenGP::SurfaceMesh::Vertex> vs;
            size_t itt = 0;
            for(auto && v : mesh_.vertices()){
                if(itt > 50) break;
                vs.push_back(v);
                //itt++;
            }

            circlecs_.emplace_back(mesh_,vs,1.0f);
            for (auto && rc : circlecs_) add(rc);

        }

    };
    
    class test_window : public csc486a::window_base {
        
        
        private:
        
        
            std::deque<csc486a::scaling_constraint> scs_;
            std::unordered_map<int,csc486a::closeness_constraint> ccs_;
        
        
        protected:
        
        
            virtual void vertex_click (vertex_click_event e) override {
                
                auto h=e.vertex.idx();
                
                std::cout << "Clicked on vertex #" << h << std::endl;
                
                auto iter=ccs_.find(h);
                if (iter==ccs_.end()) {
                    
                    std::cout << "Already scaling constraint on vertex #" << h << ", skipping" << std::endl;
                    
                    return;
                    
                }
                
                remove(iter->second);
                ccs_.erase(iter);
                scs_.emplace_back(mesh_,e.vertex,1.5f,1.0f);
                add(scs_.back());
                std::cout << "Added scaling constraint to vertex #" << h << std::endl;
                
            }
        
        
        public:
        
        
            explicit test_window (OpenGP::SurfaceMesh mesh) : csc486a::window_base(std::move(mesh)) {
                
                for (auto && v : mesh_.vertices()) ccs_.emplace(std::piecewise_construct,std::forward_as_tuple(v.idx()),std::forward_as_tuple(mesh_,v,1.0f));
                for (auto && pair : ccs_) add(pair.second);
                
            }
        
        
    };
    
}


static void main_impl (int argc, char ** argv) {
    
    if (argc!=2) {
        
        std::ostringstream ss;
        ss << "Expected 1 command line parameter, got " << (argc-1);
        throw std::runtime_error(ss.str());
        
    }
    
    OpenGP::SurfaceMesh mesh;
    if (!mesh.read(argv[1])) {
        
        std::ostringstream ss;
        ss << "Failed reading file " << argv[1];
        throw std::runtime_error(ss.str());
        
    }
    
    sphere_demo win(std::move(mesh));
    if (win.run()!=0) throw std::runtime_error("Window reported error");


    
}


int main (int argc, char ** argv) {
    
    try {
        
        try {
            
            main_impl(argc,argv);
            
        } catch (const std::exception & e) {
            
            std::cerr << "ERROR: " << e.what() << std::endl;
            throw;
            
        } catch (...) {
            
            std::cerr << "ERROR" << std::endl;
            throw;
            
        }
        
    } catch (...) {
    
        return EXIT_FAILURE;
     
    }
    
}
